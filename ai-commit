#!/bin/bash

# AI-powered commit message generator
# Ultra token-efficient using Claude 3.5 Haiku (fast and efficient model)
# Cost: ~$0.80 per 1M input tokens, ~$4.00 per 1M output tokens

generate_ai_commit_message() {
    local diff_content
    local commit_msg
    
    # Get the staged diff
    diff_content=$(git diff --cached)
    
    # Check if we have changes
    if [ -z "$diff_content" ]; then
        return 1
    fi
    
    # Check if API key is available
    if [ -z "$ANTHROPIC_API_KEY" ]; then
        return 1
    fi
    
    # Aggressively truncate diff to minimize tokens (keep only first 2000 chars)
    if [ ${#diff_content} -gt 2000 ]; then
        diff_content="${diff_content:0:2000}...[truncated]"
    fi
    
    # Concise prompt for structured response
    local prompt="Analyze this git diff and generate a conventional commit message. Use types: feat, fix, docs, style, refactor, test, chore.

Diff:
$diff_content"

    # Make API call to Claude 3.5 Haiku with structured output
    local response
    response=$(curl -s -X POST "https://api.anthropic.com/v1/messages" \
        -H "Content-Type: application/json" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "{
            \"model\": \"claude-3-5-haiku-20241022\",
            \"max_tokens\": 100,
            \"temperature\": 0.1,
            \"tool_choice\": {\"type\": \"tool\", \"name\": \"commit_message\"},
            \"tools\": [{
                \"name\": \"commit_message\",
                \"description\": \"Generate a conventional commit message\",
                \"input_schema\": {
                    \"type\": \"object\",
                    \"properties\": {
                        \"message\": {
                            \"type\": \"string\",
                            \"description\": \"Conventional commit message in format 'type: description'\",
                            \"maxLength\": 60
                        }
                    },
                    \"required\": [\"message\"]
                }
            }],
            \"messages\": [{
                \"role\": \"user\",
                \"content\": $(printf '%s' "$prompt" | jq -R -s .)
            }]
        }" 2>/dev/null)
    
    # Extract the commit message from structured response
    if [ $? -eq 0 ] && [ -n "$response" ]; then
        # Extract commit message from tool use response
        commit_msg=$(echo "$response" | jq -r '.content[0].input.message // empty' 2>/dev/null | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | head -c 72)
        
        # Validate the response
        if [ -n "$commit_msg" ] && [ "$commit_msg" != "null" ] && [ ${#commit_msg} -gt 5 ] && [ ${#commit_msg} -lt 80 ]; then
            echo "$commit_msg"
            return 0
        fi
    fi
    
    # If AI failed, return error to fall back
    return 1
}

# Enhanced generate_commit_message with AI integration
generate_commit_message() {
    # Try AI first if API key is available
    if [ -n "$ANTHROPIC_API_KEY" ]; then
        local ai_msg
        ai_msg=$(generate_ai_commit_message 2>/dev/null)
        if [ $? -eq 0 ] && [ -n "$ai_msg" ]; then
            echo "$ai_msg"
            return 0
        else
            # Debug: AI failed, falling back
            echo "âš ï¸  AI generation failed, using fallback logic" >&2
        fi
    fi
    
    # Fallback to enhanced basic logic
    local msg=""
    local added_files=$(git diff --cached --name-status | grep "^A" | wc -l | tr -d ' ')
    local modified_files=$(git diff --cached --name-status | grep "^M" | wc -l | tr -d ' ')
    local deleted_files=$(git diff --cached --name-status | grep "^D" | wc -l | tr -d ' ')
    local renamed_files=$(git diff --cached --name-status | grep "^R" | wc -l | tr -d ' ')
    
    # File type detection
    local js_files=$(git diff --cached --name-only | grep -E '\.(js|jsx|ts|tsx)$' | wc -l | tr -d ' ')
    local py_files=$(git diff --cached --name-only | grep -E '\.py$' | wc -l | tr -d ' ')
    local css_files=$(git diff --cached --name-only | grep -E '\.(css|scss|sass)$' | wc -l | tr -d ' ')
    local md_files=$(git diff --cached --name-only | grep -E '\.md$' | wc -l | tr -d ' ')
    local config_files=$(git diff --cached --name-only | grep -E '\.(json|yaml|yml|toml|ini|conf)$' | wc -l | tr -d ' ')
    local docker_files=$(git diff --cached --name-only | grep -E '(Dockerfile|docker-compose)' | wc -l | tr -d ' ')
    local test_files=$(git diff --cached --name-only | grep -iE '(test|spec)' | wc -l | tr -d ' ')
    local readme_files=$(git diff --cached --name-only | grep -iE 'readme' | wc -l | tr -d ' ')
    
    # Enhanced logic for commit message generation with conventional commits
    if [ "$added_files" -gt 0 ] && [ "$modified_files" -eq 0 ] && [ "$deleted_files" -eq 0 ]; then
        if [ "$added_files" -eq 1 ]; then
            local filename=$(git diff --cached --name-only | head -1 | basename)
            msg="feat: add $filename"
        else
            msg="feat: add $added_files new files"
        fi
    elif [ "$deleted_files" -gt 0 ] && [ "$added_files" -eq 0 ] && [ "$modified_files" -eq 0 ]; then
        if [ "$deleted_files" -eq 1 ]; then
            msg="chore: remove file"
        else
            msg="chore: remove $deleted_files files"
        fi
    elif [ "$renamed_files" -gt 0 ]; then
        msg="refactor: rename and update files"
    elif [ "$modified_files" -gt 0 ]; then
        if [ "$test_files" -gt 0 ]; then
            msg="test: update tests"
        elif [ "$readme_files" -gt 0 ]; then
            msg="docs: update documentation"
        elif [ "$config_files" -gt 0 ]; then
            msg="chore: update configuration"
        elif [ "$docker_files" -gt 0 ]; then
            msg="chore: update Docker configuration"
        elif [ "$css_files" -gt 0 ] && [ "$js_files" -eq 0 ] && [ "$py_files" -eq 0 ]; then
            msg="style: update styles"
        elif [ "$js_files" -gt 0 ]; then
            msg="feat: update JavaScript code"
        elif [ "$py_files" -gt 0 ]; then
            msg="feat: update Python code"
        elif [ "$md_files" -gt 0 ]; then
            msg="docs: update documentation"
        else
            msg="feat: update code"
        fi
    else
        local total_changes=$((added_files + modified_files + deleted_files))
        msg="chore: update codebase ($total_changes files changed)"
    fi
    
    # Add scope indicators for large changes
    local total_files=$((added_files + modified_files + deleted_files + renamed_files))
    if [ "$total_files" -gt 10 ]; then
        msg="$msg - major refactor"
    elif [ "$total_files" -gt 5 ]; then
        msg="$msg - multiple changes"
    fi
    
    echo "$msg"
}

# Enhanced quick commit function with AI integration
qc() {
    # Handle 'view' argument for preview
    if [ "$1" = "view" ]; then
        if ! git rev-parse --git-dir > /dev/null 2>&1; then
            echo "âŒ Not in a git repository"
            return 1
        fi
        
        git add .
        
        if git diff --cached --quiet; then
            echo "â„¹ï¸  No changes to commit"
            return 0
        fi
        
        echo "ğŸ“ Would commit with message:"
        generate_commit_message
        return 0
    fi
    
    # Handle 'setup' argument for configuration help
    if [ "$1" = "setup" ]; then
        qc_setup
        return 0
    fi
    
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "âŒ Not in a git repository"
        return 1
    fi
    
    echo "ğŸ“¦ Adding all changes..."
    git add .
    
    local has_changes=false
    if ! git diff --cached --quiet; then
        has_changes=true
    fi
    
    if [ "$has_changes" = true ]; then
        local commit_msg="$1"
        if [ -z "$commit_msg" ]; then
            echo "ğŸ§  Generating commit message..."
            commit_msg=$(generate_commit_message)
            
            # Show the generated message
            echo "ğŸ“ Using commit message: '$commit_msg'"
        fi
        
        if [ -z "$commit_msg" ]; then
            echo "âŒ No commit message provided"
            return 1
        fi
        
        echo "ğŸ’¾ Committing changes: $commit_msg"
        git commit -m "$commit_msg"
    else
        echo "â„¹ï¸  No new changes to commit"
    fi
    
    # Determine default branch
    local default_branch
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    if [ -z "$default_branch" ]; then
        if git show-ref --verify --quiet refs/heads/main; then
            default_branch="main"
        elif git show-ref --verify --quiet refs/heads/master; then
            default_branch="master"
        else
            default_branch=$(git branch --show-current)
        fi
    fi
    
    echo "ğŸš€ Pushing to origin/$default_branch..."
    if git push origin "$default_branch"; then
        if [ "$has_changes" = true ]; then
            echo "âœ… Successfully committed and pushed to $default_branch!"
        else
            echo "âœ… Successfully pushed to $default_branch!"
        fi
    else
        echo "âŒ Failed to push to $default_branch"
        return 1
    fi
}

# Additional utility functions
qc_setup() {
    echo "ğŸ”§ AI Commit Helper Setup"
    echo ""
    echo "ğŸ’° Cost info: Uses Claude 3.5 Haiku (fast and efficient!)"
    echo "   ~\$0.0008 input + \$0.0002 output per request (still very affordable)"
    echo ""
    echo "ğŸ”‘ Setup:"
    echo "1. Get API key: https://console.anthropic.com/"
    echo "2. Add to ~/.zshrc:"
    echo "   export ANTHROPIC_API_KEY='your-api-key-here'"
    echo "3. Reload: source ~/.zshrc"
    echo ""
    echo "ğŸ“š Usage:"
    echo "   qc           - AI-powered commit"
    echo "   qc view      - Preview commit message"
    echo "   qc setup     - Show this help"
    echo "   qc 'msg'     - Custom commit message"
    echo ""
    echo "ğŸ’¡ Without API key: Falls back to enhanced basic generation"
}

# If script is called directly, show setup info
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    qc_setup
fi
